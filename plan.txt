/** run mongo 
/Software/mongo/mongo/mongodb/bin/mongod.exe  --dbpath=/Software/mongo/mongo/mongodb-data
*/

[-] Initialize a Project with npm init
[-] create directory structure to separate all files related to thier job.
[-] install dependencies npm i ejs express express-ejs-layouts 
[-] install nodemon in devDependencies npm i nodemon -D 
[-] create a main file server.js to the root folder.
[-] setting up all template engine related setting.

<-----Important----->
[-] place routes method above or before of all template engine and middlewares realted code .
[-] Its only for temporary when your create a boilerplate page will see later then you would pace this routes method after all middleware code.

[-] set script tag inside of package.json like "dev" : "nodemon server.js" and "start" :"node server.js"
[-] variable creation file into scss folder name _variable.scss 
[-] include all css file from public folder into index.ejs and include script file app.js into end of body tag from public folder .
[-] now most thing to use public folder as a public assets that we need to use middleware and take arguments express.static('public') .
[-] design index.ejs file .

[-] Design cart.js file 
[-] create cart.ejs into views/customers  folder.
[-] create route for rendering cart page.

[-] Create layout page to prevent of using repeatation of header and footer to each pages.
[-] create layout.ejs file inside views folder
[-] paste all code having nav menubar footer.

<----- Important ------>
[-] write code <%- body %> into layout.ejs file.
[-] place all routes method after the app.use() middleware and template engine set method.

[-] create cart section that has two div 1) order 2)empty-cart
[-] order -> form submit button should be inside div otherwise it align with input element.
[-] Actually button element bydefault set as block but we set as inline-block to place into next line
[-] create anchor tag for click to login if user not logged in and here your submit button not visible.
[-]Remember <a> tag bydefault inline . so to provide padding and margin you need to first set it as inline-block to <a>

[-] create empty-cart
[-] give image width w-1/2 and set margin mx-auto for place img to center.

[-] create login-register page has placed inside of resources/auth folder.
[-] paste login form into login.ejs from tailwind .
[-] again paste this login form to register.ejs and add some input tag more.
[-] create routes get method for auth page login and register.
[-] update git and commit.

/* REcord-03 */
<---------- Separate all Route code into Route/web folder -------->
[-] create a file web.js 
[-] create a function initRoute and place all route code iinside of that.
[-] passing parameter 'app' to initRoute function becoz our route method is a method of app express object.
[-] export initRoute and import this method into server.js file.
[-] after importing call that method..! simple.


<-------- use Controller to define an action of routes -------------->

[-] create a file homeController.js 
[-] create a factory function homeController that returns an object.
[-] returning object has a property their value is a callback fnction of respective routes.
[-] exporting function and importing in web.js and place this module function inside of routes method instead of callback function.
[-] actually homeController is an function so write the code in routes method like this
     app.get('/' , homeController().index) // where index is a property has a callback fun of this routes.   

[-] Similar doing for authController that return two propert register and login routes callback function.
[-] create cartController that returns cart routes callback function.
/* End of Record */


/** Record-04 */
<-------------- MongoDB -------->
[-] first create new database 'pizza' with collection 'menus' in local mongodb.
[-] notes : collection name always must be in a "small letter".
[-] import a pizza.json file into menus collection.
[-] install mongoose npm and importing in server.js
[-] set url = mongodb:localhost/pizza
[-] call mongoose.connect(url,{urlParser:true, unifiedTopology:true})
[-] create models menu.js inside model folder of app .
[-] in menu.js create Schema of pizza that is given in collection such as name, image, price, size .
[-] come to homeController and put the code to mongodb find() to get all pizza item.
[-] collection menus has image attribute that takes only name of image .
[-] and the all images stored in a public/img folder . use image name like src="/img/<%= pizza.image %>"
[-] finally we have created dynamic menu items.

/* Ends Record-04 */


/* Record-05 */

<------- express-session --------->
[-] create session to store cart related items.
[-] what is session ?
      * first time you req to server .
      * it checks for cookie in req.header .
      * session does not work without cookie.
      * and if it not found in req.header server create new cookie.
      * send this cookie with res to user.
      * user takes this cookie from res.header and store into browser application seesion storage .
      * remember - if you close your browser still it persist in your machine mean it doesnt destroy.
      * when again user new req to server .
      * then again server checks a cookie in req.header.
      * and this it got cookie and send all realated session history mean cart items etc. to the user back.

[-] set and  config with app.use(session({}))
[-] takes config property secret, resave, unInitialised, cookie
[-] cookie : {maxAge : 1000*60*60*24}

[-] session Storage into server.
    * server store session data bydefault into a Ram of server.
    * servar has a lots of option to store session or cookie data 
               * Memory (RAM)
               * file
               * Redis(in-memory storage)
               * database
[-] so here if we go to store session in memory then it may slow our server and app.
[-] So prevent this we gonna to select mongo DB to store session.

[-] Store session data into mongoDB we need to install 'connect-mongo'
[-] connect-mongo return a class constructor that reference by MongoDbStore .
[-] call new MongoDbStore({ ....... takes parameter mongoUrl : '', autoRemove : 'native'}) and its returns a collection sessions refered by  variable "mongoStore"
[-] come to back session config and set another property  store : mongoStore .
[-] now if you save the file server.js and see your databse there sessions name collection would be created. 

/* Ends Record-05 */



/*  Record-06 */

<------- set Add to cart Action ------->
[-] first set Some Cart configuration with add-to-cart button in index.ejs file .
[-] set attribute data-pizza = "<%= JSON.stringify(pizza) %>" it takes pizza object coming from a server and store into pizza dataset.
[-] the reson behind using JSON.strinfy becoz you can only take string data into data-pizza attribute. 
[-] in app.js of resources folder we querySelectorAll(".add-to-cart") and store return arrray into addCart variable.
[-] Actually addCart variable is an Array so here we need to iterate first using addCart.forEach().
[-]Where it return single cart object and apply click eventlistener function and get data from perticular cart button. .
[-] now store the data pizza fro data-pizza of there adjacent add-to-cart button.
[-] here we store pizza object from using this code cart.dataset.pizza .
[-] but it returns stringify pizza object . So we do it prase into JSON object and store it pizza variable.
[-] now here we call another function updateCart(pizza) with passing pizza object.

[-] define updateCart function.
[-] this cart basicaly does request to the server with axios.
[-] install and import axios and then call post method with this routes "/update-cart" and pass pizza object.
[-] then we may get a success response run then() otherwise error runs catch().
[-] if we get success response and we are trying to print res result into console. We get undefind.
[-]Actually the reson behing to get undefind is we are not apply a middleware of jsonparser.
[-] so we must apply middleware app.use(express.json()). then we get result into console .

[-] However we are not defining "/update-cart" into routes/web.js and app/controller/cartController.js file .
[-] first define routes app.post('/update-route', cartController().update)
[-] now come to the cartController file and set an another propert update to cartController() function.
[-] this update property has an function that runs on you req post method /update-cart.

[-] So what exactly update property does ?
[-] Basically here we want to store cart related info into session collectio of database.
[-] so we have not any cart structure object yet.
[-] first check if any cart object available or not into session collection.
[-] if not then we create a structure of cart into session.
[-] now second time just update the cart into else section of if condition.
[-] and finally response send a json object of {totalQty : req.session.cart.totalQty}

[-] now next step to take res in the updateCart() in app.js file.
[-] here we want to display this totalQty into cart icon of index file.
[-] so first create a span into icon and select that and store totalQty value in it.

[-] cart added notifiction : we install a module noty with npm init noty.
[-] import noty js file into app.js
[-] import noty css file from node_modules into app.scss file.
[-] importing anything from node_modules add ~ to the path that represent node_modules folder.
[-] import noty css by @import '~noty/src/noty.scss' and a theme file @import '~noty/src/themes/mint.scss' into app.scss file.
[-] come to app.js file and in updateCart method call new Noty({}) and do configuration of noty into then()and catch().
[-] And give and do some styling with noty just override some css property like border-radius and padding etc. into app.scss with !important keyword.


[-] lets first create a global variable into main server.js file to store all session .
[-] use middleware app.use({res.locals.session : req.session })  .
[-] now our all session store into global variable session.

[-] now do iterative cart.js file with pizza item.
[-] first set if condition that if session.cart object found then show cart section otherwise show empty-cart section.
[-] in cart section we iterate session.cart.items but unfortunately it is not an array. 
[-] but we have lota of property and their values in an object of items.
[-] so here we apply for-of loop for values of sessioni.cart.items by this code for(let pizza of Object.values(session.cart.items))
[-] and it return a pizza variable has an property item and qty.
[-] this item takes an object of your pizza info. 

[-] now just call a pizza.item.image or pizza.item.price and many you want to place into cart section using <%= pizza.qty %> for quantity.
[-] for total price just call session.cart.totalPrice. 

/* Ends Record-06 */

<------------ End add cart section ----->


<!------- Registeration part ---------->
/* Record-07 */

[-] We do some configuration with register.ejs file.
[-] set attribute action="/register" method="POST" to the form tag.
[-] set name attrubute to each input of form tag.
[-] set button type is to submit.

[-]now define post method for '/register' in initRoute() of web.js file in web folder .
[-] and it takes a callback function comes from authcontroller.js file
    in which we create another property of authcontroller function is postRegister.
[-] now lets define an callback function post register route.
[-] inside postRegister property of authcontroller function referencing a call back function of register route of post method.
[-] in which first destructuring the req.body or query comes from register page while user registering.
[-] first print the req.body by console.log(req.body).
[-] Imp -  but unfortunately we got empty object {}
[-] Actually they did not able to parse query means req.body.
[-] Imp - to prevent this problem we need to do one configuration into server.js file.
[-] IMp- we use middleware app.use(express.urlEncoded({extended : false})).
[-] now we get the req.body object into console successfuly.  

[-] so here first validate that user fill up all fields or not.
[-] if not the we use express-flash to show error message.
[-] express-flash is used to display a message is persist only for one request and after the message flashed.
[-] using express-flash first install it and import it to the main server.js file.
[-]now call the function flash inside app.use(flash()) middleware.

[-] now come to postRegister method in which if user does not provide all data then we send a flash error mesage.
[-] call req.flash('error', ' All fields required') .
[-] So here we set the message with key 'error' and their value 'All fields reuired'.
[-] send the response back to user register page by return res.render('register').
[-] now here we create span tag inside of form which is wrap up with if block has condition message.error is available or not.
[-] Actually if you set any flash message it store into a message object has property that you provide with req.flash(key,value);
[-] so now if user does not provide all fields then req.flash('error','All fields required') send back to user with response.
[-] check condition if(message.error) is available or not . if true then our span tag display over form tag.
[-] after user again fill all the field  flash message will be destroy. becoz flash message persist only one time.
[-] let me tell u one thing here if user make mistake then thay get new fresh register page but we want that all data still there if page referesh.
[-] for that we set another flash meassage for req.flash('name', req.body.name) or req.flash('email',email).
[-] display over  register page into input tag has value="<%= messages.name %>" and similar for email.
/* Ends Record - 07 */

<----- Store registeration data into Database ---->
/* Record-08 */

[-] now store all registration data into database .
[-] first we create a model file user.js for creating model .
[-] in user.js file import first mongoose call mongoose.schema return a class is return in refer var Schema .
[-] initial Schema with new keyword pasing an object to this constructor.
[-] define schema into constructor object having propert name, email, password and role.
[-] role is basically a string and set to default : 'customer'.
[-]provide another object with property {timestamps:true}
[-]So this constructor is reference to userSchema variable.
[-] now in the end we exports mongoogse.model('User', userSchema) takes two arguments.
[-]first one that collection must be first letter capital and be singular and second argument is schema.  
[-]into postRegister method we write the code for registering user .
[-]now import User model into authController.js file that return a class store in User variable.
[-] first check the user email is already exists or not by call User.exists({email}, ()=> {} ).
[-] if the email already has then render register page with flash error message.
[-] else  create a new User({email, name, password}).save() ;
[-] return render  home page.

/* Ends Record-08 */


<----- we need to setup PASSPORT first to setup login system  ---->
/* Record-09 */

[-]first we install passport and passport local by npm i passport passport-local.
[-]create a seprate file passport.js into app/config folder .
[-] inside of passport.js we create a function init(passport) that takes a object passport as a parameter of passport module from server.js file.
[-] export this init function.
[-] now come to the server.js file and import first passport module and refer by const variable passport.
[-]now next step to import passport.js file and basically it returns a function init .
   so call directly along with importing and pass an object passport to the function.
[-] and note one thing we place passport.js impoerted line should be place after the session segment.
[-] also place another two line of passport call function with middleware app.use(passport.initialize())
    and app.use(passport.session()) after the session segment . 

[-]Now lets do main coding inside of init(passport) of passport.js file.
[-] first import passport-local module and call thier property Strategy like require('passport-local').Strategy 
    that returns a class or constructor store in a variable LocalStrategy.
[-] now come to the init function has an parameter passport object and call its middleware function passport.use(); 
[-] initialize a LocalStrategy class with new keyword inside passport.use(new LocalStrategy()).
[-] and it takes an object as first argument and second is a callback function into this constructor.
[-] inside of first argument object write set value for property of usernameField i.e email is an our username for an our application.
[-] now come to second argument is an callback function takes three parameter 
    in which first two for authentication purpose and third one is an another callback function .
[-] so here pass variable email as first argument and pass variable password as second argument 
    and last argument would be our done variable represent as callback.   

[-] now inside of callback function of new LocalStrategy , we do code for authentication of our email and password
    and return a response with done call back function like done(null, false, {message : ""}).
[-] in done() callback function first argument is for error found in passport related method .
[-] second argument is for response comes into as user otherwise set as false.
[-] Third argument is for message regarding user like if user not found then we send message "username or pasword not match" .
[-] pass last argument as an object with message property has their value a string.

[-] So lets check first for email.So here we need to import User model .
[-] after importing we call a method User.findOne({email : email}) return user if found email into db.
[-] now if user not found then call callback function done(null, false, {error:"Email not found"}) .
[-] passing false as second argument due to not found user.
[-] last argument pass an object with key errror .

[-] now if we get user then next step to check password .
[-] so we have hashed  a password by using bcrypt module into the database. 
    so first compare this hashed password with variable password come from callback argument.
[-] before of doing this we need to import bcrypt module.
[-] call bcrypt.compare(password, user.password).then().catch();
[-] into then((match)=>{}) method returns match may have true or false.
[-] now check match if its true , just return done(null, user, {message :"Successfully LoggedIn"}).
[-] where we pass user object as second argument becoz our credential hasbeen matched.

[-] in ohter hand out side the if block simply return done(null, false, {message : "username or password does not matched. "}).

[-] now come to catch block of bcrypt.compare() method just return done(null ,false, {message : "Something went wrong."}).

[-]at the end after passport.use() middleware create another two method passport.serialize() and passport.deserialize().
[-]
[-] here we have done our passport.js file.

[-] now come to route of post method login. and 
it return a callback function with req,res,next argument that is defined in our authController.js file.

[-] So inside of authController() function we define a new property postLogin represent a callback function of post login route.
[-] so begin with validation of user login credential about any empty field user if pass.
[-] then just call req.flash('error','All field required') and return res.redirct('/login')
[-] inside of that function call passport.authenticate('local', (error, user, info)=>{}) 
 has first argument is name of strategy set local and other is callback function that come from done() .
[-] check if(error) then set flash message with req.flash('message', info.message) and return next(error) ;
[-] if(!user) again set req.flash('message', info.message) and retun res.redirect('/login').
[-] and if we are getting user then just call req.login(user, (err)=>{}) has first argument user and other is callback with error argument.
[-] so check if we get error if(error) then set req.flash('error', info.message) and return next(error);
[-] otherwise return res.redirect('/') home  page.

[-] So we have completed passport.authenticated() code.
[-] but still we are missing one thing is that actually passport.authenticate() return a function.
[-] so call that function attached () paranthesis to passport.authenticate()(req,res,next) and pass req,res,next as argument .


[-] now we need to do some changes with login page, so lets come to the page.
[-] here first we set action and method attribute to the form tag with action="/login" method="POST".
[-] now set attribute for input tag name and password and set button type to submit.

[-] now main thing we have to do here attached a span tag inside a form tag.
[-] and wrap this span tag with our scriptlet tag of ejs where we apply a if block with condition messages.error .
[-] if its true then write again a code messages.error inside scriptlet tag into a span tag.
[-] finally close if blockafter span tag.

[-] So finally we completed login system code.

/* Record-09 */ 


<------------ Setup Logout System ------------------->
/* Record 10 */
[-] for logout we simply need to do only a post request .
[-] first we create a post route for logout that handle from authController.
[-] inside authController we create a property logout that holds callback function of logout route.
[-] so now write code for logout.
[-] so call req.logout() where logout() is a method of passport .
[-] at the end we just return res.redirect('/');

[-] now on menubar we applied this logout route link on logout button.
[-]but here we need to do setup one thing over there that the logout link will be show if user logged in.
[-] and if user logged in then login and register button should be gone from menubar.

[-] for that we just simply apply a if condition on menubar.
[-] if(user) where user comes from global variable res.locals.user = req.user;
[-] {.... condn true !  then show logout button and hide login and register button}
[-] else {..... condn false ! then simply show login and register button . hide logout button }

/* Record 10 Ends */

/* Record 11 */
<======== Order pizza ===========>
[-]since we have setup our cart.ejs file in which if user add pizza to the cart then we see order placed form.
[-]to place order we need to fill order form that submitted to the action '/orders' .
[-]so first we create a routes for '/orders' and callback defined in app/controller/customer/orderController.js file.
[-]in this file create a property named store refer a callback function of '/orders' routes.
[-] now just put this store function property at place of callback function of 'orders' route like orderController().store .
[-] after setup all thing just go back to store property function to define a callback function takes req,res argument.
[-] first destructuring input coming from order form placed in cart.ejs .
[-] and just validate the req.body and if anyone field didnt get then respone to the user back with error message like
       req.flash('message', 'All fields required ');
[-] although user send all info then just save that in orders collection into database.

[-] so create a model for order in which we define a schema for an order collection.
[-]we set first field a id of customer named customerId in which set property type is an Object and set another property ref has User.
[-]the 'ref' property of customerId represent to the User Collection.
[-] and set last property required as true. So we ahve done for custermerId.
[-] now come to define second field items that has object type and required is true.
[-]Actually in items field we will store ordered pizza get from req.session.cart.items .
[-] and third field for phone no. and fourth one is address will be string type.
[-] and set another field paymentType where we provide a default property and value is 'COD' .
[-] similar we create another field for status has two property first type is a String and second default property has a value 'order_placed'.
[-] in the last in order schema we define second object for timestamps property set true. 

[-] after set up model for Order we just import this into customer/orderController.js file.
[-]In store property function we just create an instance with new keyword and pass all data respect to the order model
     and refer this instance of Order to the variabe order.
[-] as an argument we pass an object has propert like customerId takes value from req.user._id.
[-] items property takes value from req.session.cart.items .
[-] and phone and address get value from user form.
[-] we dont need to provide a value for paymentType and status since we set default value for them . 
[-] now call order.save(). and its promise method so here we have two choice either we call then() method 
    or apply await keyword in front of order.save();
[-] so we pick first one  then(result =>{}) has a call back function in which we just sent back respone to the user.
[-] now here we do most important thing to delete req.session.cart .
[-] we just redirect to the home page res.redirect('/') or res.redirect('/customer/orders') build further.
[-]if we get any trouble to save an order then just execute  catch() has a callback function 
        and send response with error message like req.flash('message','Something went wrong.')


/* Record 11 Ends */completed

/* Record 12 */
<========= customer orders page ===============>
[-] We setup for orders page that ordered from user into views/customer/order.ejs.
[-] create a new table for display all orders related info.
[-] But before all of that we need to setup a route for /customer/orders.
[-] we define a new route to get all orders related to user set the callback function into customer/orderController.js file.
[-]come to the orderController.js file create a property index for callback function of '/customer/orders' route 
[-] so just call Order.find() method to get all orders related to the user.
[-] inside of find() we pass a three argument Order.find({customerId : req.user._id}, null, { createdAt : {sort : -1} })
[-]first argument represent in which basis to find data and second argument we set null becoz its for update any info
    and lastone for condition we have set to display all orders in descending manner.
[-] it also return a promise that we apply await in front of this method and return an object or array of object store in a variable orders.
[-] if we get orders means orders variable is not null then return this data orders with res.render('cutomers/order', {orders, moment}).
[-] moment is used for formating time so also send moment object module.

[-]now the time to design and /customer/orders page that is rendering from orderController and getting two object orders and moment.
[-]in customers/order.ejs file we define table tag and here we apply forEach to iterate all orders.
[-] apply orders.forEach(order => {}) return an order object in each iteration.
[-] inside table we define four coloumn for orderId  phone address and last for time when order placed.
[-] in orderId we put value got from order._id  and phone and address from order object.
[-]and last one for time we use moment object for formating time which is getting from order.createdAt.
[-]so we just apply moment(order.createdAt).format(hh : mm A) return time like 11 : 30 PM .
[-] such do that iteration inside table body and iterate table row.
[-] now we have done another functionality to show all orders.

/* Record 12 Ends */ completed


/* Record 13 */
<======= admin order panel =========== >
[-]Similar customer order page and order controller we will do for admin to show all latest order on thier dashboard.
[-] first we create and admin/order.ejs page in which create a section orders and inside 
    create a div has a tailwind class alert-success and inside there we display the flash messages.
[-] It goes off after 2 sec though apply script method setTimeout(()=> alertMsg.remove(), 2000) over here in App.js.
[-] after that we define a table to display all latest orders comes from customer.
[-] inside table we provide 5 coloumn such as order details, name, phone, address, order_status menu , time .
[-] and create a tablebody provide a name orderTableBody.and here we fetch all orders data fro our javascript.
[-] so first we create a route for get all orders their callback function define into admin/orderController.js .
[-]in orderController.js file we define orderController function in which create a property index targets to callback function of '/admin/orders' .
[-] But here we gonna ajax call to fetch all orders from our client javascript.
[-] so first we create a admin.js file inside of resources/js/ folder. inside admin.js create a function initAdmin() ;
[-] so lets do code for ajax call into this initAdmin().
[-] but first of all we just export this function by apply export keyword in front of initAdmin();
[-]similar we import this function into our app.js file by apply import {initAdmin} from './admin.js' .
[-] and call it initAdmin() at end of code into app.js.
[-] so come to admin.js file and first create a variable name orderTableBody refer to the orderTableBody element of admin/order.ejs file.
[-] create another variable orders is  used to store all orders. for the timebeing an empty array set for orders variable.
[-] now third variable we gonna create is for store markup for table body. 
[-] after creating this 3 variable orderTableBody, orders, and markup we just call ajax method to fetch all orders .
[-] for ajax calling we use module axios and we need first install axios then import it into our admin.js file.
[-] now call axios.get('admin/orders',{}).then().catch() takes first parameter for url and second for object to configure request headers.
[-] whether we call ajax so here we have to define and configuration as headers for xhr request  { headers : { "X-Requested-With" : "XMLHttpRequest"} } .
[-] and as always it returns a promise handle by then() with call back function having response.
[-] now res.data is nothing but a all orders came from admin/orders route .
[-] the store return res.data into orders variable.
[-] now call the function generateMarkUp(orders)  with pass orders array as a parameter 
     return a html table body markup store into markup variable.
[-]however we have not created a function generateMarkUp() yet . but we will create later first we complete the then().
[-] so after markup variable we store this variable into orderTableBody.innerHTML = markup.
[-] and finally this markup attached to the admin/order.ejs page.

[-]define generateMarkUp(orders) 
[-] inside function we just iterate all orders using orders.map(order => {}) method.
[-]inside callback of map return a string of table row that holds all table data with their actual value.
[-] in the string start as a template literal whether its placed all order data into thier table data.
[-] so first create <tr></tr> and in between tr tag we place <td></td> tag.
[-]now the main thing to place actual data getting from order object that we need place in thier respective position.
[-]so in first <td> tag we place orderId and list of items.
[-]for that we create a paragraph tag to place order._id and create div tag to show all list of items that user ordered .
[-] these <p> and <div> tag placed inside of our first <td> tag. 
[-] for displaying ordered items inside <div> tag we just define new function renderItems(order.items) and pass order.items. 
    and call this function into the <div> tag of first <td> .
[-] lets define renderItems(items) take items argument comes from order.items.
[-] actually this items is an object has property pizza_id as a key and their object as a value . 
    it means pizza_id holds again an object has two property item object, qty. 
[-] so here we need to iterate items object and can say values of all key of that items object actually we need only their values.
[-] for getting values of items object only call Object.values(items) return all values in an array stored into parsedItems variable.
[-] now iterate this all values to call parsedItems.map(menuItems => {}) return an object menuItems has two property item as an object and other is qty represent quantity of item.
[-] similar generateMarkUp function here also return a markup of <p> tag in which we place a variable ${menuItems.item.name} : ${menuItems.qty} .
[-] actually map method stores all returns of iteration into an array that we need to call join('') method to concatenate all <p> items .
[-] at the end we return this concatenated values from map() by apply retur keyword in front of map().
[-] So we have done it and now come back to generateMarkUp() and define another <td> tag for placing another items like name, phone, address , time of order_placed and status.

[-] in the status <td> we gonna create a form to call ajax to update the status of order .
[-] inside this <td> create a <form> tag has an action '/admin/order/status' with POST method. 
[-] inside of <form> tag create an input hidden type field set value as order._id and create next  select menu tag <select> having lots of option <option> tag .
[-] as an option we provide a five option order_placed and other four is confirmed, prepared, delivered and completed .
[-] so to find out which status is currently selected we need to apply ternary operater over option like <%= order.status === 'order_placed' ? 'selected' : '' %> .
[-] similar we will do for all option .
[-] in next <td> we pass time when order_placed by customer. for that we call moment module that get by importing in js file.
[-] inside <td> we place moment(order.createdAt).format(hh:mm A) .
[-] so this map() returns each iteration stores into an array so here we need to concatenate these all array into a string so apply join('') at the end of map().
[-] also apply return keyword in front of map() actually generateMarkUp() return a <tr> tag which is getting from map().
[-] so far we have completed our admin.js part.

[-] define orderController().
[-] now come to define callback function for '/admin/orders' route in index property of orderController() inside of admin/orderController.js file.
[-] So first we import Order model to the file and call Order.find() with popukating customerId like
    Order.find({status : {ne : 'completed'}}, null,{sort : {'createdAt' : -1 }} ).populate('customerId', '-password').exec((err, orders)=> {}) .
[-] here we are fetching all orders with populating customerId that gives us all information of customer except their password becoz we define -password as second parameter in populate().
[-] when we get orders we just check if this route call from ajax or client js by apply condition if(req.xhr) then return res.json({orders})
    otherwise simple return and redirect to '/admin/orders' page.
[-] now we also done of our  admin orderController part.


/* Record 13 Ends */


/* Record 14 */
<======== admin update order status ======>
[-] update order status is kind of post request to tell the user about their order status.
[-] in this concept we already define a form for updating status on select tag in admin/order.ejs file.
[-] in this file on each select tag in each row wrap up with a form has action '/admin/order/status' with post method.
[-] in a form tag we have two tag that first is hidden type input element contains value of order_id and second one is select tag contains order status.
[-] Actually here we gonna apply onchange attribute over <select> tag and provide value to submit form as this.form.submit().
[-] after changing status, form submitted and request goes to this '/admin/order/status' route.
[-]so first define this route and set callback function to the admin/statuscontroller.js file.
[-] inside statuscontroller.js file create a function statuscontroller() has only property update refer to the callback function of '/admin/order/status' route.
[-]So when form submitted as they goes to this route and handle by statusController().update property.
[-] inside there we first find out that perticular order by order id getting from req.body.orderId of hidden input element.
[-] or we simply update their status by calling Order.updateOne() takes three argument in which first two are an object and last argument is callback function.
[-] in first argument we pass an object with property _id and set value as req.body.orderId comes from form input element.
[-] in second object we just update their data. it means the second argument is used form updating data and 
    here we gonna update only one data {status : req.body.status}. thatswhy we are using updateOne().
[-] and the last argument provide a callback function return two argument error and updateOrder.
[-] So first check if we get error then just return a response with status code 422 i.e flash message something wrong and redirect to admin/order/status page.
[-] else we just again return a response or redirect to admin/orders with success flash message.
[-] So here we have done this update status functionality.

/* Record 14 Ends */

/* Record 15 */
<====== Single Order Tracking Status====>
[-] create a link on orderId in customer/order.ejs file.
[-] create route with passing orderId as a parameter. like '/orders/:id' where  : represent that you passing parameter id.
[-] this route handled by customer/singleOrderStatus.js file .
[-]inside customer/singleOrderStatus.js file create a function singleOrderStatus() return an object has property update holds callback function of /orders/:id route get method.
[-]lets do code inside update property and just find that order with req.params.id .
[-]first import Order model and call method Order.findById({_id : req.params.id}) provides promise handle by apply await keyword.
[-] it returns order store into order variable.
[-] so here we gonna check that order status only should be accessible by that user.
[-] apply if condition to check req.user._id with order.customerId but both are object so compare this two object
    first convert it into string by apply toString() over both object like if(order._id.toString() === req.user._id.toString()) ;
[-] if it returns true means this user order this pizza. and just render customers/singleOrder with passing {order} object.

[-] singleOrder.ejs file
[-] now design singleOrder.ejs file in which we create a tracking delivery system page.
[-] first create a div tag in a section of class status has class status-box and create ul tag have five li tag with class status_line.
[-] we crete five li tag for order status placed_order confirmed, prepared, delivered, completed.
[-] you see earlier we passed a order object with render this page. So here we goona use with input hidden element.
[-] actually here we creating input hidden type element has id hiddenInput and set value a string of order object like value = "<%= JSON.stringify(order)" %>
    and use this element in app.js for acknowledge user about their order status.

[-] so before do code for script we just style our ul tag has lots of li tag  with data-status atribute has their respective value 
    oreder_placed, confired, prepared, delivered and completed .
    and this data should be same as our order status actually we have use of these data in our script file app.js
    inside li tag we create span tag has content order status .
[-] now we set the .status ul li span:after is contain dot sybol having position absolute .
[-] if you set this absolute position then you have to set their  span tag with position relative. 
[-] similar we dor for span:before and it hold a fontline icon . so again set this position as absolute and 
    set content of icon in code given in fontline website for each icon like '\f46c' and place this code inside content of span:before.
[-] simlar we do apply line after each status . so for that we just styling li:before tag again set position as absolute 
    but before it we need to set position for li tag as relative.

[-] now create an another two class step-completed does gray all status and their line and dot after updating status 
    and current show that this status is active now and set color as primary.
[-] similar we do other styling with ul and li and span tag see in the app.scss file.


[-] no come to write script for changing status color and apply class at there.
[-] come into app.js and first call querySelector for select hiddenInput element from singleOrder.ejs file and refer to this hiddenInput variable.
[-] similar we apply document.querySelectorAll('.status-line) where this class inject to each li tag and store it into statuses variable.
[-] now check the value od hiddenInput and apply ternary operator on that if has value then return it otherwise return null.
[-] create variable order store object order getting from hiddenInput element and parse it into json object.
[-]now create another element small to display time when your order is updated.

[-]now create a function updateStatus(order) pass object order.
[-] now inside it iterate statuses contains all li items and return each li tag has their data-status atttribute.
[-] so first we remove and clear out the class .step-completed  and .current from their respective li element.
   like status.classList.remove('step-completed')

[-] after closing forEach create let variable stepCompleted is to be set as true.and the question arise over here , why is set tobe true.
[-]Actually here we know that our first status order_placed is already completed on the order time. thats why we set initially as true for stepCompleted.

[-] first iterate again statuses and access their data-status attribute and copy to dataProp vaariabe holds their value about status .
[-] now apply if condition for stepCompleted and it returns true then write code inside over here.
[-] then just add a class step-completed to that li tag it means change the color of li with gray.
[-] after if block we use another if block to check that another status is completed or not.
[-] pass condition that if dataProp === order.status then returns true.
[-] and inside of that first set false of stepCompleted .
[-]set innerText for small element is moment().format(hh:mm A) return current time with this format.
[-] now append this small tag to the li tag like status.append(small).
[-] now we need add .current class to thier next sibling li tag..
[-] so first check is it available nextElementSibling or not.
[-] if it is then just add a class .current like status.classList.add('current') to their nextElementSibling and it colored this li as primary.

[-]now we have done code for updateStatus() and need to call it so just call it at next line.
[-]Finally we have completed status tracking functionality .

/* Record 15 Ends*/


/* Record 16 */
<====== Socket Integration for real time tracking ====>



/* Record 16 Ends*/


<------------------ Record -------------------->
[-] explain server.js and why we call routes before use middleware.
[-] install git and use git to this application.
[-] add all file except config folder and node_modules folder that is keep into .gitignore file.
[-] variable creation file into scss folder name _variable.scss 
[-] import font lato from google font into app.scss 
[-] include all css file from public folder into index.ejs and include script file app.js into end of body tag from public folder .
[-] now most thing to use public folder as a public assets that we need to use middleware and take arguments express.static('public') .
[-] design index.ejs file .

<------------------ Record -------------------->
